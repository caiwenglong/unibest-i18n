/**
  * @alova/adapter-uniapp 2.0.14 (https://alova.js.org)
  * Document https://alova.js.org
  * Copyright 2025 Scott Hu. All Rights Reserved
  * Licensed under MIT (git://github.com/alovajs/alova/blob/main/LICENSE)
*/

import { isPlainObject, noop, len } from '@alova/shared';
import VueHook from 'alova/vue';

var l2CacheAdapter = {
    get(key) {
        return uni.getStorageSync(key);
    },
    set(key, value) {
        uni.setStorageSync(key, value);
    },
    remove(key) {
        uni.removeStorageSync(key);
    },
    clear() {
        uni.clearStorageSync();
    }
};

/// <reference path="../node_modules/@dcloudio/types/index.d.ts" />
/**
 * Uniapp请求适配器
 */
const requestAdapter = (elements, method) => {
    const { url, data, type, headers: header } = elements;
    let taskInstance;
    let onDownload = noop;
    let onUpload = noop;
    const responsePromise = new Promise((resolve, reject) => {
        const { config: adapterConfig } = method;
        const { requestType, timeout } = adapterConfig;
        if (requestType === 'upload') {
            const formData = {};
            const fileData = {};
            if (isPlainObject(data)) {
                Object.keys(data).forEach(key => {
                    if (['name', 'files', 'file', 'filePath'].includes(key)) {
                        fileData[key] = data[key];
                    }
                    else {
                        formData[key] = data[key];
                    }
                });
            }
            // 上传文件
            const uploadTask = (taskInstance = uni.uploadFile({
                ...adapterConfig,
                ...fileData,
                name: fileData.name,
                url,
                header,
                formData,
                timeout,
                success: res => resolve(res),
                fail: reason => reject(new Error(reason.errMsg)),
                complete: noop
            }));
            // 监听上传进度
            onUpload = (handler) => {
                uploadTask.onProgressUpdate(({ totalBytesSent, totalBytesExpectedToSend }) => {
                    handler(totalBytesSent, totalBytesExpectedToSend);
                });
            };
        }
        else if (requestType === 'download') {
            // 下载文件
            const downloadTask = (taskInstance = uni.downloadFile({
                ...adapterConfig,
                url,
                header,
                timeout,
                success: res => resolve(res),
                fail: reason => reject(new Error(reason.errMsg)),
                complete: noop
            }));
            // 监听下载进度
            onDownload = (handler) => {
                downloadTask.onProgressUpdate(({ totalBytesWritten, totalBytesExpectedToWrite }) => {
                    handler(totalBytesWritten, totalBytesExpectedToWrite);
                });
            };
        }
        else {
            // 发送普通请求
            taskInstance = uni.request({
                ...adapterConfig,
                url,
                data,
                header,
                method: type,
                timeout,
                success: res => resolve(res),
                fail: reason => reject(new Error(reason.errMsg))
            });
        }
    });
    return {
        response: () => responsePromise,
        headers: () => responsePromise.then(res => res.header || {}),
        abort: () => {
            taskInstance.abort();
        },
        onDownload,
        onUpload
    };
};

var statesHook = {
    ...VueHook,
    effectRequest(effectRequestParams, referingObject) {
        const { handler } = effectRequestParams;
        effectRequestParams.handler = (...args) => {
            // 当没有参数时，表示为立即发送请求，此时Promise.resolve让页面中的onLoad先执行
            // 当有参数时，表示通过useWatcher状态改变时发送请求，此时直接调用handler即可
            len(args) > 0 ? handler(...args) : Promise.resolve().then(() => handler(...args));
        };
        return VueHook.effectRequest(effectRequestParams, referingObject);
    }
};

const mockResponseHandler = ({ status, body }, _, currentMethod) => {
    const { requestType } = currentMethod.config;
    const responseHeaders = {};
    if (requestType === 'upload') {
        return {
            response: {
                data: body,
                statusCode: status
            },
            headers: responseHeaders
        };
    }
    if (requestType === 'download') {
        const isSuccess = status === 200;
        return {
            response: {
                tempFilePath: isSuccess ? body : '',
                statusCode: status
            },
            headers: responseHeaders
        };
    }
    return {
        response: {
            data: body,
            statusCode: status,
            header: responseHeaders,
            cookies: []
        },
        headers: responseHeaders
    };
};

function AdapterUniapp({ mockRequest } = {}) {
    return {
        statesHook,
        requestAdapter: mockRequest || requestAdapter,
        l2Cache: l2CacheAdapter
    };
}

export { AdapterUniapp as default, l2CacheAdapter as uniappL2CacheAdapter, mockResponseHandler as uniappMockResponse, requestAdapter as uniappRequestAdapter };

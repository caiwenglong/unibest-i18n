#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const commander_1 = require("commander");
const lodash_1 = require("lodash");
const path_1 = require("path");
const pkg = tslib_1.__importStar(require("../../package.json"));
const index_1 = require("../index");
const log_1 = require("../log");
const readConfig_1 = require("../readConfig");
const params = commander_1.program
    .name('openapi')
    .usage('[options]')
    .version(pkg.version)
    .option('-i, --input <string>', 'OpenAPI specification, can be a path, url')
    .option('-o, --output <string>', 'output directory')
    .option('-cfn, --configFileName <string>', 'config file name')
    .option('-cfp, --configFilePath <string>', 'config file path')
    .option('-u, --uniqueKey <string>', 'unique key')
    .option('--requestLibPath <string>', 'custom request lib path, for example: "@/request", "node-fetch" (default: "axios")')
    .option('-f, --full <boolean>', 'full replacement', true)
    .option('--enableLogging <boolean>', 'open the log', false)
    .option('--priorityRule <string>', 'priority rule, include/exclude/both (default: "include")')
    .option('--includeTags <(string|RegExp)[]>', 'generate code from include tags')
    .option('--includePaths <(string|RegExp)[]>', 'generate code from include paths')
    .option('--excludeTags <(string|RegExp)[]>', 'generate code from exclude tags')
    .option('--excludePaths <(string|RegExp)[]>', 'generate code from exclude paths')
    .option('--requestOptionsType <string>', 'custom request method options parameter type (default: "{ [key: string]: unknown }")')
    .option('--requestImportStatement <string>', `custom request import statement, for example: "const request = require('@/request')"`)
    .option('--apiPrefix <string>', `custom the prefix of the api path, for example: "api"(variable), "'api'"(string)`)
    .option('--isGenReactQuery <boolean>', 'generate react-query', false)
    .option('--reactQueryMode <string>', 'react-query mode, react/vue (default: "react")')
    .option('--isGenJavaScript <boolean>', 'generate JavaScript', false)
    .option('--isDisplayTypeLabel <boolean>', 'generate label matching type field', false)
    .option('--isGenJsonSchemas <boolean>', 'generate JSON Schemas', false)
    .option('--mockFolder <string>', 'mock file path')
    .option('--authorization <string>', 'docs authorization')
    .option('--nullable <boolean>', 'null instead of optional', false)
    .option('--isTranslateToEnglishTag <boolean>', 'translate chinese tag name to english tag name', false)
    .option('--isOnlyGenTypeScriptType <boolean>', 'only generate typescript type', false)
    .option('--isCamelCase <boolean>', 'camelCase naming of controller files and request client', true)
    .option('--isSupportParseEnumDesc <boolean>', 'parse enum description to generate enum label', false)
    .parse(process.argv)
    .opts();
function getPath(path) {
    const isUrl = path.startsWith('http');
    if (isUrl) {
        return path;
    }
    return (0, path_1.join)(process.cwd(), path);
}
const baseGenerate = (_params_) => {
    const input = getPath(_params_.input);
    const output = getPath(_params_.output);
    const options = {
        schemaPath: input,
        serversPath: output,
        requestLibPath: _params_.requestLibPath,
        full: JSON.parse(_params_.full) === true,
        enableLogging: JSON.parse(_params_.enableLogging) === true,
        priorityRule: _params_.priorityRule,
        includeTags: _params_.includeTags,
        includePaths: _params_.includePaths,
        excludeTags: _params_.excludeTags,
        excludePaths: _params_.excludePaths,
        requestOptionsType: _params_.requestOptionsType,
        apiPrefix: _params_.apiPrefix,
        isGenReactQuery: JSON.parse(_params_.isGenReactQuery) === true,
        reactQueryMode: _params_.reactQueryMode,
        isGenJavaScript: JSON.parse(_params_.isGenJavaScript) === true,
        isDisplayTypeLabel: JSON.parse(_params_.isDisplayTypeLabel) === true,
        isGenJsonSchemas: JSON.parse(_params_.isGenJsonSchemas) === true,
        mockFolder: _params_.mockFolder,
        authorization: _params_.authorization,
        nullable: JSON.parse(_params_.nullable) === true,
        isTranslateToEnglishTag: JSON.parse(_params_.isTranslateToEnglishTag) === true,
        isOnlyGenTypeScriptType: JSON.parse(_params_.isOnlyGenTypeScriptType) === true,
        isCamelCase: JSON.parse(_params_.isCamelCase) === true,
        isSupportParseEnumDesc: JSON.parse(_params_.isSupportParseEnumDesc) === true,
    };
    return options;
};
function run() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (params.input && params.output) {
            const options = baseGenerate(params);
            yield (0, index_1.generateService)((0, lodash_1.pickBy)(options, (value) => value !== null && value !== undefined && value !== ''));
            process.exit(0);
        }
        const cnf = yield (0, readConfig_1.readConfig)({
            fallbackName: 'openapi-ts-request',
            filePath: params.configFilePath,
            fileName: params.configFileName,
        });
        try {
            if (cnf) {
                const tasks = [];
                let configs = Array.isArray(cnf) ? cnf : [cnf];
                if (params.uniqueKey) {
                    configs = configs.filter((config) => config.uniqueKey === params.uniqueKey);
                }
                for (const config of configs) {
                    tasks.push((0, index_1.generateService)(config));
                }
                const results = yield Promise.allSettled(tasks);
                const errors = results.filter((result) => result.status === 'rejected');
                let errorMsg = '';
                for (let i = 0; i < errors.length; i++) {
                    const error = errors[i];
                    const cnf = configs[i];
                    errorMsg += `${cnf.uniqueKey}${cnf.uniqueKey && ':'}${error.reason}\n`;
                }
                if (errorMsg) {
                    (0, log_1.logError)(errorMsg);
                    process.exit(1);
                }
            }
            else {
                if (!params.input || !params.output) {
                    (0, log_1.logError)('Please provide either input/output options or a configuration file path and name.');
                    process.exit(1);
                }
                const options = baseGenerate(params);
                yield (0, index_1.generateService)((0, lodash_1.pickBy)(options, (value) => value !== null && value !== undefined && value !== ''));
                process.exit(0);
            }
        }
        catch (error) {
            (0, log_1.logError)(error);
            process.exit(1);
        }
    });
}
void run();

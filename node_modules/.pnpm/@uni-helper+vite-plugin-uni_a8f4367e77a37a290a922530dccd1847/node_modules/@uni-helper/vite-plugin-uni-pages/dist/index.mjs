import { spawn } from 'node:child_process';
import path, { join, dirname, resolve, extname } from 'node:path';
import process from 'node:process';
import { babelParse, isCallOf } from 'ast-kit';
import chokidar from 'chokidar';
import { lightYellow, bold, link, dim } from 'kolorist';
import MagicString from 'magic-string';
import { normalizePath, createLogger } from 'vite';
import { platform } from '@uni-helper/uni-env';
import { stringify, parse, assign } from 'comment-json';
import Debug from 'debug';
import detectIndent from 'detect-indent';
import detectNewline from 'detect-newline';
import { loadConfig } from 'unconfig';
import fs, { existsSync, readFileSync as readFileSync$1 } from 'node:fs';
import { readFile, mkdir, writeFile as writeFile$1 } from 'node:fs/promises';
import fg from 'fast-glob';
import { createRequire } from 'node:module';
import vm from 'node:vm';
import babelGenerator from '@babel/generator';
import groupBy from 'lodash.groupby';
import * as ts from 'typescript';
import * as t from '@babel/types';
import { parse as parse$2 } from '@vue/compiler-sfc';
import JSON5 from 'json5';
import { parse as parse$1 } from 'yaml';

const MODULE_ID_VIRTUAL = "virtual:uni-pages";
const RESOLVED_MODULE_ID_VIRTUAL = `\0${MODULE_ID_VIRTUAL}`;
const OUTPUT_NAME = "pages.json";
const FILE_EXTENSIONS = ["vue", "nvue", "uvue"];

function slash(str) {
  return str.replace(/\\/g, "/");
}

function getDeclaration(ctx) {
  const subPagesPath = ctx.subPageMetaData.map((sub) => {
    return sub.pages.map((v) => `"/${normalizePath(join(sub.root, v.path))}"`);
  }).flat();
  const tabsPagesPath = ctx.pagesGlobConfig?.tabBar?.list?.map((v) => {
    return `"/${v.pagePath}"`;
  }) ?? [];
  const allPagesPath = [...ctx.pageMetaData.filter((page) => !tabsPagesPath.includes(page.path)).map((v) => `"/${v.path}"`), ...subPagesPath];
  const code = `/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// Generated by vite-plugin-uni-pages

interface NavigateToOptions {
  url: ${allPagesPath.join(" |\n       ")};
}
interface RedirectToOptions extends NavigateToOptions {}

interface SwitchTabOptions {
  ${tabsPagesPath.length ? `url: ${tabsPagesPath.join(" | ")}` : ""}
}

type ReLaunchOptions = NavigateToOptions | SwitchTabOptions;

declare interface Uni {
  navigateTo(options: UniNamespace.NavigateToOptions & NavigateToOptions): void;
  redirectTo(options: UniNamespace.RedirectToOptions & RedirectToOptions): void;
  switchTab(options: UniNamespace.SwitchTabOptions & SwitchTabOptions): void;
  reLaunch(options: UniNamespace.ReLaunchOptions & ReLaunchOptions): void;
}
`;
  return code;
}
async function writeFile(filePath, content) {
  await mkdir(dirname(filePath), { recursive: true });
  return await writeFile$1(filePath, content, "utf-8");
}
async function writeDeclaration(ctx, filepath) {
  const originalContent = existsSync(filepath) ? await readFile(filepath, "utf-8") : "";
  const code = getDeclaration(ctx);
  if (!code)
    return;
  if (code !== originalContent)
    await writeFile(filepath, code);
}

function invalidatePagesModule(server) {
  const { moduleGraph } = server;
  const mods = moduleGraph.getModulesByFile(RESOLVED_MODULE_ID_VIRTUAL);
  if (mods) {
    const seen = /* @__PURE__ */ new Set();
    mods.forEach((mod) => {
      moduleGraph.invalidateModule(mod, seen);
    });
  }
}
const debug = {
  hmr: Debug("vite-plugin-uni-pages:hmr"),
  routeBlock: Debug("vite-plugin-uni-pages:routeBlock"),
  options: Debug("vite-plugin-uni-pages:options"),
  pages: Debug("vite-plugin-uni-pages:pages"),
  subPages: Debug("vite-plugin-uni-pages:subPages"),
  error: Debug("vite-plugin-uni-pages:error"),
  cache: Debug("vite-plugin-uni-pages:cache"),
  declaration: Debug("vite-plugin-uni-pages:declaration"),
  definePage: Debug("vite-plugin-uni-pages:definePage")
};
function extsToGlob(extensions) {
  return extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0] || "";
}
function isTargetFile(path2) {
  const ext = path2.split(".").pop();
  return FILE_EXTENSIONS.includes(ext);
}
function mergePageMetaDataArray(pageMetaData) {
  const pageMetaDataObj = groupBy(pageMetaData, "path");
  const result = [];
  for (const path2 in pageMetaDataObj) {
    const _pageMetaData = pageMetaDataObj[path2];
    const options = _pageMetaData[0];
    for (const page of _pageMetaData) {
      options.style = Object.assign(options.style ?? {}, page.style ?? {});
      Object.assign(options, page);
    }
    result.push(options);
  }
  return result;
}
async function execScript(options) {
  const { imports = [], code, filename } = options;
  let jsCode = "";
  try {
    const tmpCode = `${imports.join("\n")}
 export default ${code}`;
    jsCode = ts.transpileModule(tmpCode, {
      compilerOptions: {
        module: ts.ModuleKind.CommonJS,
        // 生成的模块格式为 CommonJS（Node.js 默认格式）
        target: ts.ScriptTarget.ES2022,
        // 编译后的 JavaScript 目标版本
        noEmit: true,
        // 不生成输出文件
        strict: false,
        // 关闭所有严格类型检查选项
        noImplicitAny: false,
        // 允许表达式和 any 类型
        strictNullChecks: false,
        // 关闭严格的 null 和 undefined 检查
        strictFunctionTypes: false,
        // 关闭函数参数的严格逆变比较
        strictBindCallApply: false,
        // 关闭对 bind、call 和 apply 方法的严格类型检查
        strictPropertyInitialization: false,
        // 关闭类属性初始化的严格检查
        noImplicitThis: false,
        // 允许 this 表达式具有隐式的 any 类型
        alwaysStrict: false,
        // 不以严格模式解析并为每个源文件生成 "use strict" 指令
        allowJs: true,
        // 允许编译 JavaScript 文件
        checkJs: false,
        // 不检查 JavaScript 文件中的类型
        skipLibCheck: true,
        // 跳过对 TypeScript 声明文件 (*.d.ts) 的类型检查
        esModuleInterop: true,
        // 启用 ES 模块互操作性，允许使用 import 导入 CommonJS 模块
        removeComments: true
        // 删除注释
      },
      jsDocParsingMode: ts.JSDocParsingMode.ParseNone
      // 不解析 JSDoc
    }).outputText;
    const dir = path.dirname(filename);
    const vmContext = {
      module: {},
      exports: {},
      __filename: filename,
      __dirname: dir,
      require: createRequire(dir),
      import: (id) => import(id)
    };
    const script = new vm.Script(jsCode, { filename });
    await script.runInNewContext(vmContext, {
      timeout: 1e3
      // 设置超时避免长时间运行
    });
    const result = vmContext.exports.default || vmContext.exports;
    if (typeof result === "function") {
      return Promise.resolve(result());
    }
    return Promise.resolve(result);
  } catch (error) {
    throw new Error(`EXEC SCRIPT FAIL IN ${filename}: ${error.message} 

${jsCode}

`);
  }
}
function getDefaultExport(expr) {
  return expr.default === void 0 ? expr : expr.default;
}
const babelGenerate = getDefaultExport(babelGenerator);

function getPageFiles(path, options) {
  const { exclude } = options;
  const ext = extsToGlob(FILE_EXTENSIONS);
  const files = fg.sync(`**/*.${ext}`, {
    ignore: exclude,
    onlyFiles: true,
    cwd: path
  });
  return files;
}
function checkPagesJsonFile(path) {
  if (!fs.existsSync(path)) {
    writeFileSync(path, stringify({ pages: [{ path: "" }] }, null, 2));
    return false;
  }
  return true;
}
function readFileSync(path) {
  try {
    return fs.readFileSync(path, { encoding: "utf-8" });
  } catch {
    return "";
  }
}
function writeFileSync(path, content) {
  fs.writeFileSync(path, content, { encoding: "utf-8" });
}

function resolveOptions(userOptions, viteRoot = process.cwd()) {
  const {
    dts = true,
    configSource = "pages.config",
    homePage = ["pages/index", "pages/index/index"],
    mergePages = true,
    dir = "src/pages",
    subPackages = [],
    outDir = "src",
    exclude = ["node_modules", ".git", "**/__*__/**"],
    routeBlockLang = "json5",
    minify = false,
    debug = false,
    onBeforeLoadUserConfig = () => {
    },
    onAfterLoadUserConfig = () => {
    },
    onBeforeScanPages = () => {
    },
    onAfterScanPages = () => {
    },
    onBeforeMergePageMetaData = () => {
    },
    onAfterMergePageMetaData = () => {
    },
    onBeforeWriteFile = () => {
    },
    onAfterWriteFile = () => {
    }
  } = userOptions;
  const root = viteRoot || slash(process.env.VITE_ROOT_DIR || process.cwd());
  const resolvedDirs = resolvePageDirs(dir, root, exclude);
  const resolvedSubDirs = subPackages.map((dir2) => slash(dir2));
  const resolvedHomePage = typeof homePage === "string" ? [homePage] : homePage;
  const resolvedConfigSource = typeof configSource === "string" ? [{ files: configSource }] : configSource;
  const resolvedDts = !dts ? false : typeof dts === "string" ? dts : resolve(viteRoot, "uni-pages.d.ts");
  const resolvedOptions = {
    dts: resolvedDts,
    configSource: Array.isArray(resolvedConfigSource) ? resolvedConfigSource : [resolvedConfigSource],
    homePage: resolvedHomePage,
    mergePages,
    dirs: resolvedDirs,
    subPackages: resolvedSubDirs,
    outDir,
    exclude,
    routeBlockLang,
    root,
    minify,
    debug,
    onBeforeLoadUserConfig,
    onAfterLoadUserConfig,
    onBeforeScanPages,
    onAfterScanPages,
    onBeforeMergePageMetaData,
    onAfterMergePageMetaData,
    onBeforeWriteFile,
    onAfterWriteFile
  };
  return resolvedOptions;
}
function resolvePageDirs(dir, root, exclude) {
  const dirs = fg.sync(slash(dir), {
    ignore: exclude,
    onlyDirectories: true,
    dot: true,
    unique: true,
    cwd: root
  });
  return dirs;
}

function parseCustomBlock(block, filePath, routeBlockLang) {
  const lang = block.lang ?? routeBlockLang;
  const attr = {
    type: "page",
    ...block.attrs
  };
  let content;
  debug.routeBlock(`use ${lang} parser`);
  if (lang === "json5") {
    try {
      content = JSON5.parse(block.content);
    } catch (err) {
      throw new Error(
        `Invalid JSON5 format of <${block.type}> content in ${filePath}
${err.message}`
      );
    }
  } else if (lang === "jsonc") {
    try {
      content = parse(block.content);
    } catch (err) {
      throw new Error(
        `Invalid JSONC format of <${block.type}> content in ${filePath}
${err.message}`
      );
    }
  } else if (lang === "json") {
    try {
      content = JSON.parse(block.content);
    } catch (err) {
      throw new Error(
        `Invalid JSON format of <${block.type}> content in ${filePath}
${err.message}`
      );
    }
  } else if (lang === "yaml" || lang === "yml") {
    try {
      content = parse$1(block.content);
    } catch (err) {
      throw new Error(
        `Invalid YAML format of <${block.type}> content in ${filePath}
${err.message}`
      );
    }
  }
  return {
    attr,
    content: content ?? {}
  };
}
function getRouteSfcBlock(sfc) {
  return sfc?.customBlocks.find((b) => b.type === "route");
}
function getRouteBlock(path, blockStr, routeBlockLang) {
  if (!blockStr)
    return;
  return parseCustomBlock(blockStr, path, routeBlockLang);
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class Page {
  constructor(ctx, path) {
    __publicField$1(this, "ctx");
    __publicField$1(this, "path");
    __publicField$1(this, "rawOptions", "");
    __publicField$1(this, "options");
    this.ctx = ctx;
    this.path = path;
  }
  async getPageMeta(forceUpdate = false) {
    if (forceUpdate || !this.options) {
      await this.readPageMeta();
    }
    return this.options;
  }
  async hasChanged() {
    const { hasChanged } = await this.readPageMeta();
    return hasChanged;
  }
  async readPageMeta() {
    try {
      const { relativePath } = this.path;
      const { path, ...others } = await this.readPageMetaFromFile();
      this.options = {
        path: path ?? normalizePath(relativePath.replace(extname(relativePath), "")),
        ...others
      };
      const raw = this.options ? JSON.stringify(this.options) : "";
      const hasChanged = this.rawOptions !== raw;
      this.rawOptions = raw;
      return {
        options: this.options,
        hasChanged
      };
    } catch (err) {
      throw new Error(`Read page options fail in ${this.path.relativePath}
${err.message}`);
    }
  }
  async readPageMetaFromFile() {
    const content = readFileSync$1(this.path.absolutePath, "utf-8");
    const sfc = parseSFC(content, { filename: this.path.absolutePath });
    const meta = await tryPageMetaFromMacro(sfc);
    if (meta) {
      return meta;
    }
    return tryPageMetaFromCustomBlock(sfc, this.ctx.options.routeBlockLang);
  }
}
function parseSFC(code, options) {
  try {
    return parse$2(code, {
      pad: "space",
      ...options
    }).descriptor || parse$2({
      source: code,
      ...options
    });
  } catch (error) {
    throw new Error(`[vite-plugin-uni-pages] Vue3's "@vue/compiler-sfc" is required. 
Original error: 
${error}`);
  }
}
async function tryPageMetaFromMacro(sfc) {
  const sfcScript = sfc.scriptSetup || sfc.script;
  if (!sfcScript) {
    return void 0;
  }
  const ast = babelParse(sfcScript.content, sfcScript.lang || "js", {
    plugins: [["importAttributes", { deprecatedAssertSyntax: true }]]
  });
  const macro = findMacro(ast.body, sfc.filename);
  if (macro) {
    const imports = findImports(ast.body).map((imp) => babelGenerate(imp).code);
    const [macroOption] = macro.arguments;
    const code = babelGenerate(macroOption).code;
    const result = await execScript({
      imports,
      code,
      filename: sfc.filename
    });
    return {
      type: "page",
      ...result
    };
  }
  return void 0;
}
async function tryPageMetaFromCustomBlock(sfc, routeBlockLang) {
  const block = getRouteSfcBlock(sfc);
  const routeBlock = getRouteBlock(sfc.filename, block, routeBlockLang);
  const pageMeta = {
    type: routeBlock?.attr.type ?? "page"
  };
  if (routeBlock) {
    assign(pageMeta, routeBlock.content);
  }
  return pageMeta;
}
function findMacro(stmts, filename) {
  let macro;
  for (const stmt of stmts) {
    let node = stmt;
    if (stmt.type === "ExpressionStatement")
      node = stmt.expression;
    if (isCallOf(node, "definePage")) {
      macro = node;
      break;
    }
  }
  if (!macro)
    return;
  const [opt] = macro.arguments;
  if (opt && !t.isFunctionExpression(opt) && !t.isArrowFunctionExpression(opt) && !t.isObjectExpression(opt)) {
    debug.definePage(`definePage() \u53C2\u6570\u4EC5\u652F\u6301\u51FD\u6570\u6216\u5BF9\u8C61: ${filename}`);
    return;
  }
  return macro;
}
function findImports(stmts) {
  return stmts.map((node) => node.type === "ImportDeclaration" ? node : void 0).filter((node) => !!node);
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
let lsatPagesJson = "";
class PageContext {
  constructor(userOptions, viteRoot = process.cwd()) {
    __publicField(this, "_server");
    __publicField(this, "pagesGlobConfig");
    __publicField(this, "pagesConfigSourcePaths", []);
    __publicField(this, "pages", /* @__PURE__ */ new Map());
    // abs path -> Page
    __publicField(this, "subPages", /* @__PURE__ */ new Map());
    // root -> abs path -> page
    __publicField(this, "pageMetaData", []);
    __publicField(this, "subPageMetaData", []);
    __publicField(this, "resolvedPagesJSONPath", "");
    __publicField(this, "resolvedPagesJSONIndent", "  ");
    __publicField(this, "resolvedPagesJSONNewline", "\n");
    __publicField(this, "resolvedPagesJSONEofNewline", true);
    __publicField(this, "rawOptions");
    __publicField(this, "root");
    __publicField(this, "options");
    __publicField(this, "logger");
    __publicField(this, "withUniPlatform", false);
    this.rawOptions = userOptions;
    this.root = slash(viteRoot);
    debug.options("root", this.root);
    this.options = resolveOptions(userOptions, this.root);
    const debugOption = this.options.debug;
    if (debugOption) {
      const prefix = "vite-plugin-uni-pages:";
      const suffix = typeof debugOption === "boolean" ? "*" : debugOption;
      Debug.enable(`${prefix}${suffix}`);
    }
    this.resolvedPagesJSONPath = path.join(this.root, this.options.outDir, OUTPUT_NAME);
    const resolvedPagesJSONContent = readFileSync(this.resolvedPagesJSONPath);
    this.resolvedPagesJSONIndent = detectIndent(resolvedPagesJSONContent).indent || "  ";
    this.resolvedPagesJSONNewline = detectNewline(resolvedPagesJSONContent) || "\n";
    this.resolvedPagesJSONEofNewline = (resolvedPagesJSONContent.at(-1) ?? "\n") === this.resolvedPagesJSONNewline;
    debug.options(this.options);
  }
  setLogger(logger) {
    this.logger = logger;
  }
  async loadUserPagesConfig() {
    const configSource = this.options.configSource;
    const { config, sources } = await loadConfig({ cwd: this.root, sources: configSource, defaults: {} });
    this.pagesGlobConfig = config.default || config;
    this.pagesConfigSourcePaths = sources;
    debug.options(this.pagesGlobConfig);
  }
  async scanPages() {
    const pageDirFiles = this.options.dirs.map((dir) => {
      return { dir, files: getPagePaths(dir, this.options) };
    });
    const paths = pageDirFiles.map((page) => page.files).flat();
    debug.pages(paths);
    const pages = /* @__PURE__ */ new Map();
    for (const path2 of paths) {
      const page = this.pages.get(path2.absolutePath) || new Page(this, path2);
      pages.set(path2.absolutePath, page);
    }
    this.pages = pages;
  }
  async scanSubPages() {
    const paths = {};
    const subPages = /* @__PURE__ */ new Map();
    for (const dir of this.options.subPackages) {
      const pagePaths = getPagePaths(dir, this.options);
      paths[dir] = pagePaths;
      const pages = /* @__PURE__ */ new Map();
      for (const path2 of pagePaths) {
        const page = this.subPages.get(dir)?.get(path2.absolutePath) || new Page(this, path2);
        pages.set(path2.absolutePath, page);
      }
      subPages.set(dir, pages);
    }
    debug.subPages(JSON.stringify(paths, null, 2));
    this.subPages = subPages;
  }
  setupViteServer(server) {
    if (this._server === server)
      return;
    this._server = server;
    this.setupWatcher(server.watcher);
  }
  async setupWatcher(watcher) {
    watcher.add(this.pagesConfigSourcePaths);
    const targetDirs = [...this.options.dirs, ...this.options.subPackages].map((v) => slash(path.resolve(this.root, v)));
    const isInTargetDirs = (filePath) => targetDirs.some((v) => slash(path.resolve(this.root, filePath)).startsWith(v));
    watcher.on("add", async (path2) => {
      path2 = slash(path2);
      if (!isTargetFile(path2))
        return;
      if (!isInTargetDirs(path2))
        return;
      debug.pages(`File added: ${path2}`);
      if (await this.updatePagesJSON())
        this.onUpdate();
    });
    watcher.on("change", async (path2) => {
      path2 = slash(path2);
      if (!isTargetFile(path2))
        return;
      if (!isInTargetDirs(path2))
        return;
      debug.pages(`File changed: ${path2}`);
      debug.pages(targetDirs);
      debug.pages(isInTargetDirs(path2));
      if (await this.updatePagesJSON(path2))
        this.onUpdate();
    });
    watcher.on("change", async (path2) => {
      if (this.pagesConfigSourcePaths.includes(path2)) {
        debug.pages(`Config source changed: ${path2}`);
        if (await this.updatePagesJSON())
          this.onUpdate();
      }
    });
    watcher.on("unlink", async (path2) => {
      path2 = slash(path2);
      if (!isTargetFile(path2))
        return;
      if (!isInTargetDirs(path2))
        return;
      debug.pages(`File removed: ${path2}`);
      if (await this.updatePagesJSON())
        this.onUpdate();
    });
  }
  onUpdate() {
    if (!this._server)
      return;
    invalidatePagesModule(this._server);
    debug.hmr("Reload generated pages.");
    this._server.ws.send({
      type: "full-reload"
    });
  }
  /**
   * parse pages rules && set page type
   * @param pages page path array
   * @param type  page type
   * @param overrides custom page config
   * @returns pages rules
   */
  async parsePages(pages, type, overrides) {
    const jobs = [];
    for (const [_, page] of pages) {
      jobs.push(page.getPageMeta());
    }
    const generatedPageMetaData = await Promise.all(jobs);
    const customPageMetaData = overrides || [];
    const result = customPageMetaData.length ? mergePageMetaDataArray(generatedPageMetaData.concat(customPageMetaData)) : generatedPageMetaData;
    const parseMeta = result.filter(
      (page, index, self) => self.findLastIndex((item) => page.path === item.path) === index
    );
    return type === "main" ? this.setHomePage(parseMeta) : parseMeta;
  }
  /**
   * set home page
   * @param result pages rules array
   * @returns pages rules
   */
  setHomePage(result) {
    const hasHome = result.some(({ type }) => type === "home");
    if (!hasHome) {
      const isFoundHome = result.some((item) => {
        const isFound = this.options.homePage.find((v) => v === item.path);
        if (isFound)
          item.type = "home";
        return isFound;
      });
      if (!isFoundHome) {
        this.logger?.warn('No home page found, check the configuration of pages.config.ts, or add the `homePage` option to UniPages in vite.config.js, or add `type="home"` to the routeBlock of your vue page.', {
          timestamp: true
        });
      }
    }
    result.sort((page) => page.type === "home" ? -1 : 0);
    return result;
  }
  async mergePageMetaData() {
    const pageMetaData = await this.parsePages(this.pages, "main", this.pagesGlobConfig?.pages);
    this.pageMetaData = pageMetaData;
    debug.pages(this.pageMetaData);
  }
  async mergeSubPageMetaData() {
    const subPageMaps = {};
    const subPackages = this.pagesGlobConfig?.subPackages || [];
    for (const [dir, pages] of this.subPages) {
      const basePath = slash(path.join(this.options.root, this.options.outDir));
      const root = slash(path.relative(basePath, path.join(this.options.root, dir)));
      const globPackage = subPackages?.find((v) => v.root === root);
      subPageMaps[root] = await this.parsePages(pages, "sub", globPackage?.pages);
      subPageMaps[root] = subPageMaps[root].map((page) => ({ ...page, path: slash(path.relative(root, page.path)) }));
    }
    for (const { root, pages } of subPackages) {
      if (root && !subPageMaps[root])
        subPageMaps[root] = pages || [];
    }
    const subPageMetaData = Object.keys(subPageMaps).map((root) => ({ root, pages: subPageMaps[root] })).filter((meta) => meta.pages.length > 0);
    this.subPageMetaData = subPageMetaData;
    debug.subPages(this.subPageMetaData);
  }
  async updatePagesJSON(filepath) {
    if (filepath) {
      let page = this.pages.get(filepath);
      if (!page) {
        let subPage;
        for (const [_, pages2] of this.subPages) {
          subPage = pages2.get(filepath);
          if (subPage) {
            break;
          }
        }
        page = subPage;
      }
      if (page && !await page.hasChanged()) {
        debug.cache(`The route block on page ${filepath} did not send any changes, skipping`);
        return false;
      }
    }
    checkPagesJsonFile(this.resolvedPagesJSONPath);
    this.options.onBeforeLoadUserConfig(this);
    await this.loadUserPagesConfig();
    this.options.onAfterLoadUserConfig(this);
    if (this.options.mergePages) {
      this.options.onBeforeScanPages(this);
      await this.scanPages();
      await this.scanSubPages();
      this.options.onAfterScanPages(this);
    }
    this.options.onBeforeMergePageMetaData(this);
    await this.mergePageMetaData();
    await this.mergeSubPageMetaData();
    this.options.onAfterMergePageMetaData(this);
    const pagesMap = /* @__PURE__ */ new Map();
    const pages = this.withUniPlatform ? this.pageMetaData.filter((v) => !/\..*$/.test(v.path) || v.path.includes(platform)).map((v) => {
      v.path = v.path.replace(/\..*$/, "");
      return v;
    }) : this.pageMetaData;
    pages.forEach((v) => pagesMap.set(v.path, v));
    this.pageMetaData = [...pagesMap.values()];
    this.options.onBeforeWriteFile(this);
    const data = {
      ...this.pagesGlobConfig,
      pages: this.pageMetaData,
      subPackages: this.subPageMetaData
    };
    const pagesJson = stringify(
      data,
      null,
      this.options.minify ? void 0 : this.resolvedPagesJSONIndent
    ) + (this.resolvedPagesJSONEofNewline ? this.resolvedPagesJSONNewline : "");
    this.generateDeclaration();
    if (lsatPagesJson === pagesJson) {
      debug.pages("PagesJson Not have change");
      return false;
    }
    writeFileSync(this.resolvedPagesJSONPath, pagesJson);
    lsatPagesJson = pagesJson;
    this.options.onAfterWriteFile(this);
    return true;
  }
  virtualModule() {
    const pages = `export const pages = ${this.resolveRoutes()};`;
    const subPackages = `export const subPackages = ${this.resolveSubRoutes()};`;
    return [pages, subPackages].join("\n");
  }
  resolveRoutes() {
    return stringify(this.pageMetaData, null, 2);
  }
  resolveSubRoutes() {
    return stringify(this.subPageMetaData, null, 2);
  }
  generateDeclaration() {
    if (!this.options.dts)
      return;
    debug.declaration("generating");
    return writeDeclaration(this, this.options.dts);
  }
}
function getPagePaths(dir, options) {
  const pagesDirPath = slash(path.resolve(options.root, dir));
  const basePath = slash(path.join(options.root, options.outDir));
  const files = getPageFiles(pagesDirPath, options);
  debug.pages(dir, files);
  const pagePaths = files.map((file) => slash(file)).map((file) => ({
    relativePath: path.relative(basePath, slash(path.resolve(pagesDirPath, file))),
    absolutePath: slash(path.resolve(pagesDirPath, file))
  }));
  return pagePaths;
}

function defineUniPages(config) {
  return config;
}

async function restart() {
  return new Promise((resolve) => {
    const build = spawn(process.argv.shift(), process.argv, {
      cwd: process.env.VITE_ROOT_DIR || process.cwd(),
      detached: true,
      env: process.env
    });
    build.stdout?.pipe(process.stdout);
    build.stderr?.pipe(process.stderr);
    build.on("close", (code) => {
      resolve(process.exit(code));
    });
  });
}
function VitePluginUniPages(userOptions = {}) {
  let ctx;
  const resolvedPagesJSONPath = path.join(
    process.env.VITE_ROOT_DIR || process.cwd(),
    userOptions.outDir ?? "src",
    OUTPUT_NAME
  );
  const isValidated = checkPagesJsonFile(resolvedPagesJSONPath);
  return {
    name: "vite-plugin-uni-pages",
    enforce: "pre",
    async configResolved(config) {
      ctx = new PageContext(userOptions, config.root);
      if (config.plugins.some((v) => v.name === "vite-plugin-uni-platform"))
        ctx.withUniPlatform = true;
      const logger = createLogger(void 0, {
        prefix: "[vite-plugin-uni-pages]"
      });
      ctx.setLogger(logger);
      await ctx.updatePagesJSON();
      if (config.command === "build") {
        if (!isValidated) {
          ctx.logger?.warn("In build mode, if `pages.json` does not exist, the plugin cannot create the complete `pages.json` before the uni-app, so it restarts the build.", {
            timestamp: true
          });
          await restart();
        }
        if (config.build.watch)
          ctx.setupWatcher(chokidar.watch([...ctx.options.dirs, ...ctx.options.subPackages]));
      }
    },
    // Applet do not support custom route block, so we need to remove the route block here
    async transform(code, id) {
      if (!FILE_EXTENSIONS.find((ext) => id.endsWith(ext))) {
        return null;
      }
      const sfc = parseSFC(code, { filename: id });
      let macro;
      if (sfc.scriptSetup) {
        const ast = babelParse(sfc.scriptSetup.content, sfc.scriptSetup.lang || "js");
        macro = findMacro(ast.body, sfc.filename);
      }
      if (!macro && sfc.script) {
        const ast = babelParse(sfc.script.content, sfc.script.lang || "js");
        macro = findMacro(ast.body, sfc.filename);
      }
      const routeBlock = sfc.customBlocks.find((block) => block.type === "route");
      if (!macro && !routeBlock)
        return null;
      if (macro && routeBlock)
        throw new Error(`\u4E0D\u652F\u6301\u6DF7\u5408\u4F7F\u7528 definePage() \u548C <route/> ${id}`);
      const s = new MagicString(code);
      if (macro)
        s.remove(macro.start, macro.end);
      if (routeBlock) {
        console.log(lightYellow("\u8B66\u544A\uFF1A"), `${bold("<route/>")} \u6807\u7B7E\u5DF2\u5E9F\u5F03\uFF0C\u5C06\u5728\u4E0B\u4E00\u4E2A\u7248\u672C\u4E2D\u79FB\u9664\uFF0C\u8BF7\u4F7F\u7528 definePage() \u4EE3\u66FF\uFF1B${link("\u67E5\u770B\u8FC1\u79FB\u6307\u5357", "https://uni-helper.js.org/vite-plugin-uni-pages/definePage")}\u3002`);
        console.log(dim(id));
        console.log();
        const routeBlockMatches = s.original.matchAll(
          /<route[^>]*>([\s\S]*?)<\/route>/g
        );
        for (const match of routeBlockMatches) {
          const index = match.index;
          const length = match[0].length;
          s.remove(index, index + length);
        }
      }
      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: s.generateMap({
            source: id,
            includeContent: true,
            file: `${id}.map`
          })
        };
      }
    },
    configureServer(server) {
      ctx.setupViteServer(server);
    },
    resolveId(id) {
      if (id === MODULE_ID_VIRTUAL)
        return RESOLVED_MODULE_ID_VIRTUAL;
    },
    load(id) {
      if (id === RESOLVED_MODULE_ID_VIRTUAL)
        return ctx.virtualModule();
    }
  };
}

export { FILE_EXTENSIONS, MODULE_ID_VIRTUAL, OUTPUT_NAME, Page, PageContext, RESOLVED_MODULE_ID_VIRTUAL, VitePluginUniPages, babelGenerate, checkPagesJsonFile, debug, VitePluginUniPages as default, defineUniPages, execScript, extsToGlob, findImports, findMacro, getPageFiles, getRouteBlock, getRouteSfcBlock, invalidatePagesModule, isTargetFile, mergePageMetaDataArray, parseCustomBlock, parseSFC, readFileSync, resolveOptions, resolvePageDirs, tryPageMetaFromCustomBlock, tryPageMetaFromMacro, writeFileSync };
